# Preliminary evaluation

I'm glad that the language successfully compiles and runs. It may be very simplistic and rudimentary at the moment, but it works, which is awesome. 

The user experience could be improved by adding in some essential features to support modification - I need to add naming of drinks and the ability to use modifications on an existing recipe. To that end, I'll need to add a global namespace for Recipes, as well as continue reasonining out the semantics and implementation strategy for modifications. In particular, figuring out how much freedom to give the user in removing or swapping out certain ingredients - the easiest implementation would be to only allow removing or swapping **all** of a particular ingredient, but is that enough to cover sufficiently many use cases? As far as the implementation goes, it's remained pretty clean so far but the challenge will be in making sure it remains clean as I implement more and more features. 

When I evaluate my project so far, I look back at the questions I asked myself in the Plan document. The language doesn't have many big features yet, but I'm hoping that this will not be the case after the next week or so. I have had to make compromises on the language syntax too - replacing `of` with `@` pained me greatly, but after a lot of pondering and regex experimenting I couldn't find a way around it (at least, not while sticking to PackratParsing). I think I don't really have a good sense of how easy the language is to use, considering it's my baby - I'll need to rely on frequently asking my classmates to test it and give me feedback. 

I also realized that my evaluation plan from the beginning of the project is a bit out of date - in it, the implementation focuses heavily on evaluating the quantity and quality of the various backends. However, I have been spending most of my thinking time on the parser, IR, and early semantics (transforming sets of instructions and error checking) as opposed to the backend - I guess these seem like more interesting problems to me. In that sense, I think I'd still be okay if the only backend I had was the dinky print backend, as long as I make the rest of the language really robust. However, in my plan I also put value in structuring the implementation code well, and that is a measure of quality that I stand behind. I want the codebase for the language to be really easy to read and understand for an outside viewer. While I may not have learned how to use Scala like a master (I don't have any Traits in the language yet, for instance, or even use any pattern matching) I want the codebase to demonstrate some basic Scala and language design competency on my part.

The biggest trouble I've run into so far was trying to add multi-word ingredients. I eventually had to compromise and change the keyword `of` to `@` so the regex parser could locate the token that splits the quantity and the ingredient. Implementing "functions" is also proving to be tricky; particularly with the parser - I have to figure out what a program should ultimately parse into. I think it'll end up looking like a bunch of Recipes and then a Body that contains a set of instructions. The semantics will need to separate the recipes and put them into the global namespace and then run the lines in the Body, substituting in Recipes in where necessary.

All that remains to do before the end of the project is to add a new feature, test it on some users, gather feedback and ideas for additional useful features, and repeat until the 11th of December. In particular, some of the things I want to accomplish are as follows: adding the ability to call drinks within other drinks, adding the ability to modify drinks, having the semantics understand modifications and know how to transform the initial program into a final list of instructions to execute, and maybe (if I have time) sprucing up the print backend or adding a new backend. Of course, considering how "according to plan" the project has been going so far, I wouldn't be surprised if many other concerns come up between now and the final submimssion date for the project (for instance, I haven't had any features disagree with each other yet, which means it's past time for that to happen). 
